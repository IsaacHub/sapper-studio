<ul>
	{#each items as item (item.basename)}
		{#if item.isDir}
			<li class="directory {item.isDotfile ? 'hidden' : ''} {open[item.basename] ? 'open' : ''}">
				<span on:click="toggle(item.basename)">{item.basename}</span>

				{#if open[item.basename]}
					<svelte:self dir={item.resolved}/>
				{/if}
			</li>
		{:else}
			<li class="file {item.isDotfile ? 'hidden' : ''} {item.resolved === $selectedFile ? 'selected' : ''}">
				<span on:click="$set({ selectedFile: item.resolved })">{item.basename}</span>
			</li>
		{/if}

	{/each}
</ul>

<style>
	ul {
		list-style: none;
		padding: 0 0 0 1em;
		margin: 0;
	}

	li {
		font-size: 14px;
		background: no-repeat 0.2em 0.4em;
		background-size: 1em 1em;
		line-height: 1;
		margin: 0;
	}

	span {
		display: block;
		padding: 0.4em 0 0.4em 1.5em;
		white-space: pre;
	}

	span:hover {
		background-color: rgba(255,255,255,0.1);
	}

	.hidden span {
		color: #999;
	}

	.file {
		/* background-image: url('../assets/icons/file-white.svg'); */
	}

	.directory {
		background-image: url('../assets/icons/chevronright-white.svg');
	}

	.directory.open {
		background-image: url('../assets/icons/chevrondown-white.svg');
	}

	.selected {
		background-color: rgba(255,255,255,0.1);
	}
</style>

<script>
	import * as fs from 'fs';
	import * as path from 'path';
	import * as child_process from 'child_process';

	let watcherProc;
	const subscribers = {};

	function watch(dir, component) {
		if (!watcherProc) {
			const worker = path.resolve(__dirname, '../workers/watch-directory.js');
			watcherProc = child_process.fork(worker, {
				cwd: process.cwd()
			});

			watcherProc.on('message', message => {
				if (message.type === 'directory-changed') {
					const components = subscribers[message.dir];
					if (components) {
						components.forEach(component => {
							component.updateContents();
						});
					}
				}
			});
		}

		const components = (subscribers[dir] || (subscribers[dir] = []));
		components.push(component);

		if (components.length === 1) {
			watcherProc.send({
				command: 'start-watching',
				dir
			});
		}

		return {
			close() {
				const index = components.indexOf(component);
				if (index !== -1) components.splice(index, 1);

				if (components.length === 0) {
					watcherProc.send({
						command: 'stop-watching',
						dir
					});
				}
			}
		};
	}

	export default {
		data() {
			return {
				items: [],
				open: {}
			};
		},

		oncreate() {
			const { dir } = this.get();

			this.on('destroy', () => {
				this.destroyed = true;
				if (this.watcher) this.watcher.close();
			});

			this.updateContents();
			this.createWatcher();
		},

		methods: {
			updateContents() {
				const { dir } = this.get();

				const items = fs.readdirSync(dir)
					.map(file => {
						const resolved = path.join(dir, file);
						const stats = fs.statSync(resolved);

						return {
							resolved,
							basename: file,
							isDir: stats.isDirectory(),
							isDotfile: file[0] === '.'
						};
					})
					.sort((a, b) => {
						if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
						return a.basename < b.basename ? -1 : 1;
					});

				this.set({ items });
			},

			createWatcher() {
				const { dir } = this.get();
				this.watcher = watch(dir, this);
			},

			toggle(basename) {
				const { open } = this.get();
				open[basename] = !open[basename];
				this.set({ open });
			}
		}
	};
</script>